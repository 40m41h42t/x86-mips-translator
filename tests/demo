原有程序如下：

#include <string.h>
char str1[20] = "helloworld!"; // 在.data中
int main(int argc, char const *argv[])
{
  char str2[20] = "";
  callcopy(str2, str1);
  return 0;
}
void callcopy(char *dest, char *src)
{
  strcpy(dest, src);
}

X86生成代码如下：

0804852b <callcopy>:
 804852b: 55                    push   %ebp
 804852c: 89 e5                 mov    %esp,%ebp
 804852e: 83 ec 08              sub    $0x8,%esp
 8048531: 83 ec 08              sub    $0x8,%esp
 8048534: ff 75 0c              pushl  0xc(%ebp)
 8048537: ff 75 08              pushl  0x8(%ebp)
 804853a: e8 71 fe ff ff        call   80483b0 <strcpy@plt>
 804853f: 83 c4 10              add    $0x10,%esp
 8048542: 90                    nop
 8048543: c9                    leave  
 8048544: c3                    ret    

队列法处理实例：
main 入队
出队，得到 main
开始逐指令翻译 main
扫到 callcopy，将其加入队列
main 扫描完成
出队，得到 callcopy
开始逐指令翻译 callcopy
扫到 strcpy@plt，标记这里是一个动态链接的函数
callcopy 扫描完成
队列空，用户函数识别完毕

翻译模式：
逐个指令进行翻译，翻译过程中若涉及到.data节数据则从.data节提取出来
以 callcopy 为例，得到如下翻译代码（此处以重新翻译为x86为例，实际上是翻译成MIPS指令）：

#include <string.h>
void callcopy(char *dest, char *src)
{
  _asm
  {
    /* 保护现场不做了 */
    pushl  0xc(%ebp)
    pushl  0x8(%ebp)
    call   strcpy
    add    $0x10,%esp
    /* 还原现场也不做了 */
  }
}

将以上代码使用gcc再次编译，得到目标可执行文件。